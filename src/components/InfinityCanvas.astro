---
import evaPod from "./icons/eva-pod.svg";
// import logosData from "../data/starfield-logos.json";
import { brandLogos } from "../data/starfield-logos.js";
---

<section
  id="infinity"
  class="infinity text-center min-h-screen px-0 overflow-hidden relative"
>
  <!-- Canvas for starfield + logos -->
  <canvas id="starfield-canvas" class="absolute inset-0 w-full h-full"></canvas>

  <!-- Centerpiece pod stays as normal DOM -->
  <img
    id="eva-pod"
    src={evaPod.src}
    alt="Eva pod"
    class="size-10 lg:size-20 absolute top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2"
    width="80"
    height="80"
  />

  <div class="container-bootstrap relative z-10"></div>
</section>

<style>
  .infinity {
    background-image: url("../img/infinity.webp?ver=28082025");
    background-repeat: no-repeat;
    background-position: center;
    background-size: cover;
  }

  /* Keep your brand-logo sizing if you still want CSS-based scaling */
  /* .brand-logo {
    width: auto;
    height: 16px;
  }

  @media (min-width: 768px) {
    .brand-logo {
      height: 32px;
    }
  }

  .brand-mark {
    width: auto;
    height: 32px;
  }

  @media (min-width: 768px) {
    .brand-mark {
      height: 64px;
    }
  } */
</style>

<script is:inline define:vars={{ logos: brandLogos }}>
  let breakPointMd = 768;

  // Wait for GSAP to be ready
  function initGsapInfinity() {
    window.gsapMatchMedia.add(
      {
        prefersReducedMotion: `(prefers-reduced-motion: reduce)`,
        noPreference: `(prefers-reduced-motion: no-preference)`,
        isDesktop: `(min-width: ${breakPointMd}px)`,
        isMobile: `(max-width: ${breakPointMd - 1}px)`,
        hasFinePointer: `(any-pointer: fine)`,
      },
      (context) => {
        let {
          noPreference,
          prefersReducedMotion,
          isDesktop,
          isMobile,
          hasFinePointer,
        } = context.conditions;
        let reduceMotion = window.reduceMotionCB?.checked || false;
        const infinitySection = document.getElementById("infinity");
        if (!infinitySection) return;

        if (!reduceMotion && noPreference) {
          if (!window.gsap) return;
          const { gsap } = window;

          // EVA pod animation stays the same
          const evaPod = document.getElementById("eva-pod");
          if (evaPod) {
            gsap.fromTo(
              evaPod,
              { scale: 10, opacity: 0 },
              {
                scale: 0.1,
                opacity: 1,
                ease: "power1.out",
                scrollTrigger: {
                  trigger: infinitySection,
                  start: "top top",
                  end: "+=100%",
                  scrub: 1,
                  pin: hasFinePointer && isDesktop ? infinitySection : false,
                },
              }
            );
          }

          // Canvas-based starfield instead of DOM logos
          const canvas = document.getElementById("starfield-canvas");
          const ctx = canvas.getContext("2d");

          function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
          }
          window.addEventListener("resize", resizeCanvas); // NOTE: will this fire onOrientationChange as well?
          resizeCanvas();

          // Update the Logo class to support responsive sizing
          class Logo {
            constructor({ src, speed, type, width, height, className }) {
              this.img = new Image();
              this.img.src = src;
              this.speed = speed;
              this.type = type;

              // Responsive sizing multiplier - half size on mobile
              const sizeMultiplier = isDesktop ? 1 : 0.5;

              // Handle sizing like the DOM version
              this.img.onload = () => {
                if (width && height) {
                  this.width = width * sizeMultiplier;
                  this.height = height * sizeMultiplier;
                } else if (height) {
                  // Set height, calculate width maintaining aspect ratio
                  this.height = height * sizeMultiplier;
                  this.width =
                    (this.img.naturalWidth / this.img.naturalHeight) * this.height;
                } else if (width) {
                  // Set width, calculate height maintaining aspect ratio
                  this.width = width * sizeMultiplier;
                  this.height =
                    (this.img.naturalHeight / this.img.naturalWidth) * this.width;
                } else {
                  // Fallback based on type - matches your CSS classes
                  if (this.type === "logo") {
                    this.height = 32 * sizeMultiplier; // 32px desktop, 16px mobile
                    this.width =
                      (this.img.naturalWidth / this.img.naturalHeight) * this.height;
                  } else if (this.type === "mark") {
                    this.height = 64 * sizeMultiplier; // 64px desktop, 32px mobile
                    this.width =
                      (this.img.naturalWidth / this.img.naturalHeight) * this.height;
                  } else {
                    // Default fallback if type is not specified
                    this.height = 32 * sizeMultiplier; // 32px desktop, 16px mobile
                    this.width =
                      (this.img.naturalWidth / this.img.naturalHeight) * this.height;
                  }
                }
              };

              // GSAP-controlled properties
              this.x = 0;
              this.y = 0;
              this.scale = 0.05;
              this.angle = Math.random() * Math.PI * 2;
            }

            draw() {
              if (!this.img.complete) return;

              const centerX = canvas.width / 2;
              const centerY = canvas.height / 2;
              const finalX = centerX + this.x;
              const finalY = centerY + this.y;
              const finalWidth = this.width * this.scale;
              const finalHeight = this.height * this.scale;

              ctx.drawImage(
                this.img,
                finalX - finalWidth / 2,
                finalY - finalHeight / 2,
                finalWidth,
                finalHeight
              );
            }
          }

          // Initialize with GSAP but render to canvas
          // Calculate viewport dimensions for proper distance
          const viewportWidth = window.innerWidth;
          const viewportHeight = window.innerHeight;
          const maxDistance = Math.max(viewportWidth, viewportHeight) * 0.85; // 85% of largest viewport dimension

          const logoObjs = logos.map((logoData, index) => {
            const logo = new Logo(logoData);

            // Use GSAP to animate the logo properties
            const distance = maxDistance + Math.random() * (maxDistance * 0.3);
            const endX = Math.cos(logo.angle) * distance;
            const endY = Math.sin(logo.angle) * distance;

            const timelineStarfield = gsap.timeline({ repeat: -1 });
            const moveDuration = 5 + Math.random() * 4;
            const restartOffset = moveDuration * 0.5;
            const initialDelay = (index / logos.length) * restartOffset;

            timelineStarfield
              .fromTo(
                logo, // Animate the logo object properties directly
                {
                  x: 0,
                  y: 0,
                  scale: 0.05,
                },
                {
                  x: endX,
                  y: endY,
                  scale: 2 + Math.random() * 2.5,
                  duration: moveDuration,
                  ease: "cubic-bezier(0, 0, 0, 1)", // Keep your beautiful easing!
                  delay: initialDelay,
                }
              )
              .set(logo, {
                x: 0,
                y: 0,
                scale: 0.05,
                delay: -restartOffset,
              });

            return logo;
          });

          // Animation loop just draws, GSAP handles the animation
          function animate() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            for (const logo of logoObjs) {
              logo.draw();
            }
            requestAnimationFrame(animate);
          }
          animate();

          console.debug("Canvas starfield initiated.");
        } else {
          // Reduced motion - hide EVA pod and clean up
          console.debug("prefers-reduced-motion (canvas starfield skipped)");
        }

        // optionally return a cleanup function
        // return () => console.debug("cleanup");
      }
    );
  }

  // Listen for GSAP ready event
  document.addEventListener("gsap:ready", () => initGsapInfinity());

  // Fallback if GSAP is already loaded
  if (window.gsap) initGsapInfinity();
</script>
