<section
  class="stars relative"
>
<div data-parallax-factor="0.1" data-parallax-max-y="0" class="moon-surface parallax-layer absolute inset-0 bg-[url('/img/moon-surface.png?ver=28082025')] bg-bottom bg-no-repeat bg-[length:100%_auto] max-md:bg-[length:140%_auto] 2xl:bg-[center_300px]"></div>
  <div class="container-bootstrap relative">
    <div class="grid md:grid-cols-12 -mx-[15px]">
      <div class="md:col-span-10 md:col-start-2 px-[15px]">
        <h1
          class="font-serif font-light leading-[1.1] mb-6 uppercase text-[46px]"
        >
          It's full of stars
        </h1>
        <p class="mb-3">
          Expect extraordinary taste, subtle details and sophisticated code.
          <br />
          <a href="#monolith" class="text-primary">Expect the unexpected.</a>
        </p>
        <a
          id="monolith"
          class="monolith-container parallax-layer block text-primary focus-visible:outline-0"
          data-parallax-factor="2.0"
          href="https://www.youtube.com/watch?v=ou6JNQwPWE0"
          rel="noopener noreferrer"
        >
          <div class="monolith show-front">
            <figure class="front bg-primary/50 block absolute outline-offset-0"></figure>
            <figure class="back bg-primary/50 block absolute outline-offset-0"></figure>
            <figure class="right bg-primary/50 block absolute outline-offset-0"></figure>
            <figure class="left bg-primary/50 block absolute outline-offset-0"></figure>
            <figure class="top bg-primary/50 block absolute outline-offset-0"></figure>
            <figure class="bottom bg-primary/50 block absolute outline-offset-0"></figure>
          </div>
        </a>
      </div>
    </div>
    <div class="moonlanders -mb-px"></div>
  </div>
</section>

<style>
  /* Parallax base (only applied when JS enhances) */
  .parallax-layer {
    will-change: transform;
  }

  .moonlanders {
    background: transparent url("/img/moonlanders.png?ver=28082025") top left
      no-repeat;
    width: 525px;
    height: 300px;
    background-size: 100% 100%;
    position: absolute;
    bottom: -100px;
    right: 110px;
  }

  @media (min-width: 1200px) {
    .moonlanders {
      right: 130px;
    }
  }

  @media (min-width: 768px) and (max-width: 991px) {
    .moonlanders {
      right: 70px;
    }
  }

  @media (max-width: 767px) {
    .moonlanders {
      bottom: -40px;
      height: 200px;
      right: 50px;
      width: 350px;
    }
  }

  @media (max-width: 480px) {
    .moonlanders {
      bottom: -40px;
      height: 150px;
      right: 30px;
      width: 263px;
    }
  }

  /* monolith */
  .monolith-container {
    width: 120px;
    height: 270px;
    position: relative;
    perspective: 500px;
    margin-top: 50px;
  }

  .monolith {
    animation: spinX 30s infinite linear;
    position: absolute;
    transform-style: preserve-3d;
    transition: transform 1s ease 0s;
    width: 100%;
    height: 100%;

    figure {
      backface-visibility: hidden;
    }

    .front,
    .back {
      height: 270px;
      width: 120px;
    }

    .right,
    .left {
      height: 270px;
      left: 45px;
      width: 30px;
    }

    .top,
    .bottom {
      height: 30px;
      top: 120px;
      width: 120px;
    }

    .front {
      transform: rotateX(0deg) translateZ(15px);
    }

    .back {
      transform: rotateX(-180deg) translateZ(15px);
    }

    .right {
      transform: rotateY(90deg) translateZ(60px);
    }

    .left {
      transform: rotateY(-90deg) translateZ(60px);
    }

    .top {
      transform: rotateX(90deg) translateZ(135px);
    }

    .bottom {
      transform: rotateX(-90deg) translateZ(135px);
    }

    .no-csstransforms3d & {
      .back,
      .right,
      .left,
      .top,
      .bottom {
        display: none;
      }
    }
  }
</style>

<script is:inline>
  // Generic mouse-move parallax for any .parallax-layer in the section.
  // Each layer can define: data-parallax-factor (0..1+), optional data-parallax-max-x / -max-y.
  (function () {
    const section = document.querySelector('section.stars');
    if (!section) return;
    const reduced = window.matchMedia('(prefers-reduced-motion: reduce)').matches;
    if (reduced) return;

    const layers = Array.from(section.querySelectorAll('.parallax-layer'));
    if (!layers.length) return;

    // Ensure defaults & cache base transforms (if pre-existing).
    layers.forEach(el => {
      if (!el.dataset.parallaxFactor) el.dataset.parallaxFactor = '0.5';
      if (!el.dataset.parallaxMaxX) el.dataset.parallaxMaxX = '30';
      if (!el.dataset.parallaxMaxY) el.dataset.parallaxMaxY = '20';
      el.dataset._baseTransform = getComputedStyle(el).transform === 'none' ? '' : getComputedStyle(el).transform;
    });

    let inView = false;
    const io = new IntersectionObserver((entries) => {
      entries.forEach(e => { if (e.target === section) inView = e.isIntersecting; });
    }, { threshold: 0 });
    io.observe(section);

    let targetX = 0, targetY = 0;
    let currentX = 0, currentY = 0;
    const ease = 0.08;
    let rafId = 0;

    function animate() {
      const dx = targetX - currentX;
      const dy = targetY - currentY;
      if (Math.abs(dx) > 0.01 || Math.abs(dy) > 0.01) {
        currentX += dx * ease;
        currentY += dy * ease;
        applyTransforms(currentX, currentY);
        rafId = requestAnimationFrame(animate);
      } else {
        currentX = targetX; currentY = targetY;
        applyTransforms(currentX, currentY);
        rafId = 0;
      }
    }

    function applyTransforms(nx, ny) {
      layers.forEach(el => {
        const f = parseFloat(el.dataset.parallaxFactor || '0');
        const maxX = parseFloat(el.dataset.parallaxMaxX || '30');
        const maxY = parseFloat(el.dataset.parallaxMaxY || '20');
        const base = el.dataset._baseTransform || '';
        const tx = (nx * maxX * f).toFixed(2);
        const ty = (ny * maxY * f).toFixed(2);
        el.style.transform = `${base} translate3d(${tx}px, ${ty}px, 0)`.trim();
      });
    }

    function onPointerMove(ev) {
      if (!inView) return;
      const rect = section.getBoundingClientRect();
      const xNorm = (ev.clientX - (rect.left + rect.width / 2)) / (rect.width / 2);
      const yNorm = (ev.clientY - (rect.top + rect.height / 2)) / (rect.height / 2);
      targetX = Math.max(-1, Math.min(1, xNorm));
      targetY = Math.max(-1, Math.min(1, yNorm));
      if (!rafId) rafId = requestAnimationFrame(animate);
    }

    window.addEventListener('pointermove', onPointerMove, { passive: true });
    document.addEventListener('visibilitychange', () => {
      if (document.hidden) { targetX = 0; targetY = 0; if (!rafId) rafId = requestAnimationFrame(animate); }
    });
  })();
</script>
